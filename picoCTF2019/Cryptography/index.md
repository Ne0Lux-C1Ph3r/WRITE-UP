
<h1 align="center">Cryptography</h1>


<h3>The Numbers - Points: 50</h3>
The numbers... what do they mean?

<p align="center"><img src="../Files/number.png"></img></p>

``` shell
Crypto alphabetic range

Flag: PICOCTF{THENUMBERSMASON}
```


<h3>13 - Points: 100</h3>
Cryptography can be easy, do you know what ROT13 is? cvpbPGS{abg_gbb_onq_bs_n_ceboyrz}

``` shell
Crypto ROT13 of Caesar

Flag: picoCTF{not_too_bad_of_a_problem}
```


<h3>Easy1 - Points: 100</h3>
The one time pad can be cryptographically secure, but not when you know the key. Can you solve this? We've given you the encrypted flag, key, and a table to help UFJKXQZQUNB with the key of SOLVECRYPTO. Can you use this table to solve it?. 

``` shell
Crypto Vigenere with key SOLVECRYPTO

Flag: picoCTF{CRYPTOISFUN}
```


<h3>caesar - Points: 100</h3>
Decrypt this message. You can find the ciphertext in /problems/caesar_0_22aa542fadadcc37b6ec6037c493ec9f on the shell server.

picoCTF{jyvzzpunaolybipjvunfzpthre}

``` shell
Crypto ROT7 of Caesar

Flag: picoCTF{crossingtherubicongysimakx}
```


<h3>Flags - Points: 200</h3>
What do the flags mean?

<p align="center"><img src="../Files/flag.png"></img></p>

``` shell
Crypto Popham

Flag: PICOCTF{F1AG5AND5TUFF}
```


<h3>Mr-Worldwide - Points: 200</h3>
A musician left us a message. What's it mean?

picoCTF{(35.028309, 135.753082)(46.469391, 30.740883)(39.758949, -84.191605)(41.015137, 28.979530)(24.466667, 54.366669)(3.140853, 101.693207)_(9.005401, 38.763611)(-3.989038, -79.203560)(52.377956, 4.897070)(41.085651, -73.858467)(57.790001, -152.407227)(31.205753, 29.924526)}

``` shell
Crypto coordinate GPS

Flag: picoCTF{KODIAK_ALASKA}
```


<h3>Tapping - Points: 200</h3>
Theres tapping coming in from the wires. What's it saying nc 2019shell1.picoctf.com 49914.

.--. .. -.-. --- -.-. - ..-. { -- ----- .-. ... ...-- -.-. ----- -.. ...-- .---- ... ..-. ..- -. ----. ----- ...-- .---- ....- ----- ....- ....- ---.. }

``` shell
Crypto Morse

Flag: PICOCTF{M0RS3C0D31SFUN1618996775}
```


<h3>la cifra de - Points: 200</h3>
I found this cipher in an old book. Can you figure out what it says? Connect with nc 2019shell1.picoctf.com 32203.


Encrypted message:
Ne iy nytkwpsznyg nth it mtsztcy vjzprj zfzjy rkhpibj nrkitt ltc tnnygy ysee itd tte cxjltk
Ifrosr tnj noawde uk siyyzre, yse Bnretèwp Cousex mls hjpn xjtnbjytki xatd eisjd
Iz bls lfwskqj azycihzeej yz Brftsk ip Volpnèxj ls oy hay tcimnyarqj dkxnrogpd os 1553 my Mnzvgs Mazytszf Merqlsu ny hox moup Wa inqrg ipl. Ynr. Gotgat Gltzndtg Gplrfdo 
Ltc tnj tmvqpmkseaznzn uk ehox nivmpr g ylbrj ts ltcmki my yqtdosr tnj wocjc hgqq ol fy oxitngwj arusahje fuw ln guaaxjytrd catizm tzxbkw zf vqlckx hizm ceyupcz yz tnj fpvjc hgqqpohzCZK{m311a50_0x_a1rn3x3_h1ah3x0j4of52l}
Yse lncsz bplr-izcarpnzjo dkxnroueius zf g uzlefwpnfmeznn cousex mzwkapr, cfd mgip axtfnj 1467 gj Lkty Bgyeiyyl Argprzn.
Ehk Atgksèce Inahkw ts zmprkkzrk xzmkytmkx narqpd zmp Argprzn Oiyh zr Gqmexyt Cousex.
Ny 1508, Jumlntjd Txnehkrtuy nyvkseej yse yt-narqpd zfmurf ceiyl (a sferoc zf ymtfzjo arusahjes) zmlt ctflj qltkw me g hciznnar hzmvtyety zf zmp Volpnèxj Nivmpr.
Hjwlgxz’s yjnoti moupwez fapkfcej ny 1555 ay f notytnafeius zf zmp fowdt. Zmp lubpr nfwvkx zf zmp arusahjes gwp nub dhokeej wpgaqlrrd, muz yse gqahggpty fyd zmp itipx rjetkwd axj xidjo be rpatx zf g ryestyii ppy vmcayj, hhohs cgs me jnqfkwpnz bttn jlcn hzrxjdpusoety.

``` shell
Crypto Vigenere with key FLAG

It is interesting how in history people often receive credit for things they did not create 
During the course of history, the Vigenère Cipher has been reinvented many times
It was falsely attributed to Blaise de Vigenère as it was originally described in 1553 by Giovan Battista Bellaso in his book La cifra del. Sig. Giovan Battista Bellaso
For the implementation of this cipher a table is formed by sliding the lower half of an ordinary alphabet for an apparently random number of places with respect to the upper half picoCTF{b311a50_0r_v1gn3r3_c1ph3r0e4df52f} 
The first well-documented description of a polyalphabetic cipher however, was made around 1467 by Leon Battista Alberti.
The vigenère Cipher is therefore sometimes called the Alberti Disc or Alberti Cipher.
In 1508, Johannes Trithemius invented the so-called tabula recta (a matrix of shifted alphabets) that would later be a critical component of the Vigenère Cipher.
Bellaso’s second booklet appeared in 1555 as a continuation of the first. The lower halves of the alphabets are now shifted 
regularly, but the alphabets and the index letters are mixed by means of a mnemonic key phrase, which can be different with each 
correspondent.

Flag: picoCTF{b311a50_0r_v1gn3r3_c1ph3r0e4df52f}
```


<h3>rsa-pop-quiz - Points: 200</h3>
Class, take your seats! It's PRIME-time for a quiz... nc 2019shell1.picoctf.com 49989.

``` shell
AS LAST YEAR!!!!!!!!!!!!!!!

Flag: picoCTF{wA8_th4t$_ill3aGal..o6e437df2}
```


<h3>miniRSA - Points: 300</h3>
Lets decrypt this: ciphertext? Something seems a bit small.

n= 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673


e= 3


c= 2205316413931134031074603746928247799030155221252519872650052684269978265826043435142038105241236650339034731484646667260370795732926830852800100801582852694992848644675152814990683881915631833289789415298017780422616397351991535601598053 


``` shell
import gmpy

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m



gs = gmpy.mpz(c)
gm = gmpy.mpz(n)
g3 = gmpy.mpz(3)
 
mask = gmpy.mpz(0x8080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808000)
test = 0
while True:
  if test == 0:
   gs = gs
  else:
   gs += gm
  root,exact = gs.root(g3)
  if (root & mask).bit_length() < 8:
    print root
    break

print '\n',hex(int(root))[2:-1].decode('hex')


"""

13016382529449106065894479374027604750406953699090365388203668037786343075898237

picoCTF{n33d_a_lArg3r_e_a8e8b26c}

"""
Flag: picoCTF{n33d_a_lArg3r_e_a8e8b26c}
```


<h3>waves over lambda - Points: 300</h3>
We made alot of substitutions to encrypt this. Can you decrypt it? Connect with nc 2019shell1.picoctf.com 21903.

``` shell
Crypto alphabetic substitution

Congrats here is your flag - frequency_is_c_over_lambda_lwwmuvrvab
-------------------------------------------------------------------------------
Having had some time at my disposal when in london, i had visited the british museum, and made search among the books and maps in the library regarding transylvania; it had struck me that some foreknowledge of the country could hardly fail to have some importance in dealing with a nobleman of that country. i find that the district he named is in the extreme east of the country, just on the borders of three states, transylvania, moldavia and bukovina, in the midst of the carpathian mountains; one of the wildest and least known portions of europe. i was not able to light on any map or work giving the exact locality of the castle dracula, as there are no maps of this country as yet to compare with our own ordnance survey maps; but i found that bistritz, the post town named by count dracula, is a fairly well-known place. i shall enter here some of my notes, as they may refresh my memory when i talk over my travels with mina.

Flag: picoCTF{frequency_is_c_over_lambda_lwwmuvrvab}
```


<h3>b00tl3gRSA2 - Points: 400</h3>
In RSA d is alot bigger than e, why dont we use d to encrypt instead of e? Connect with nc 2019shell1.picoctf.com 1723.


c= 52212391697701595752040100162899116582652416194722854311586131120597019490285379299243364590694080079441959062938762846730346143721077154153061069317189641193018934325617654569039722805776724847189942892887195376920282617718484127153727437210040458445955862349994106202300885479569165998172352082542246347413


n= 87990471752685087038269573090588618776821672271716292678061557850389955798345849920084878437621660409756676343956790611398136686779157799420814927337479064337802807838465549123102254939662822704991833503917320037580650080808068868833798137497567473704889838751185537147679870888297605865879590073518740214247


e= 74317356347198950559673706139789001863884676217347634902554914196448345565189707045279128982981701461178590806216949672898073760216163719293534471716915293366058619078496630125427954721463933908939181082317532490304762648191257650534973577317613097759952312255083879620825511711149293750917577684566439654617



``` shell
import random

############################
## Wiener's Attack module ##
############################

# Calculates bitlength
def bitlength(x):
  assert x >= 0
  n = 0
  while x > 0:
    n = n+1
    x = x>>1
  return n
  
# Squareroots an integer
def isqrt(n):
  if n < 0:
    raise ValueError('square root not defined for negative numbers')  
  if n == 0:
    return 0
  a, b = divmod(bitlength(n), 2)
  x = 2**(a+b)
  while True:
    y = (x + n//x)//2
    if y >= x:
      return x
    x = y

# Checks if an integer has a perfect square
def is_perfect_square(n):
  h = n & 0xF; #last hexadecimal "digit"    
  if h > 9:
    return -1 # return immediately in 6 cases out of 16.
  # Take advantage of Boolean short-circuit evaluation
  if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
    # take square root if you must
    t = isqrt(n)
    if t*t == n:
      return t
    else:
      return -1    
  return -1

# Calculate a sequence of continued fractions
def partial_quotiens(x, y):
  partials = []
  while x != 1:
    partials.append(x // y)
    a = y
    b = x % y
    x = a
    y = b
  #print partials
  return partials

# Helper function for convergents
def indexed_convergent(sequence):
  i = len(sequence) - 1
  num = sequence[i]
  denom = 1
  while i > 0:
    i -= 1
    a = (sequence[i] * num) + denom
    b = num
    num = a
    denom = b
  #print (num, denom)
  return (num, denom)

# Calculate convergents of a  sequence of continued fractions
def convergents(sequence):
  c = []
  for i in range(1, len(sequence)):
    c.append(indexed_convergent(sequence[0:i]))
  #print c
  return c

# Calculate `phi(N)` from `e`, `d` and `k`
def phiN(e, d, k):
  return ((e * d) - 1) / k

# Wiener's attack, see http://en.wikipedia.org/wiki/Wiener%27s_attack for more information
def wiener_attack(N,e):
  (p,q,d) = (0,0,0)
  conv=convergents(partial_quotiens(e,N))
  for frac in conv:
    (k,d)=frac
    if k == 0:
      continue
    y = -(N - phiN(e, d, k) + 1)
    discr = y*y - 4*N
    if(discr>=0):
      # since we need an integer for our roots we need a perfect squared discriminant
      sqr_discr = is_perfect_square(discr)
      # test if discr is positive and the roots are integers
      if sqr_discr!=-1 and (-y+sqr_discr)%2==0:
        p = ((-y+sqr_discr)/2)
        q = ((-y-sqr_discr)/2)
        return p, q, d
  return p, q, d

################################
## End Wiener's Attack module ##
################################

print wiener_attack(n,e)



#(11850494432495276726691495533500479222483389938240591726684644854827639776112493684476977400304766242810044412617799062029034834600945942220202628406668493L, 7425046461471358322756247267234703593056856585874641255976152184072662982246645777972541838811164109159246013209509764634962895352497234259132295663778179L, 65537L)



import libnum

p = 11850494432495276726691495533500479222483389938240591726684644854827639776112493684476977400304766242810044412617799062029034834600945942220202628406668493
q = 7425046461471358322756247267234703593056856585874641255976152184072662982246645777972541838811164109159246013209509764634962895352497234259132295663778179

phi=(p-1)*(q-1)
d = libnum.modular.invmod(e, phi)
print libnum.n2s(pow(c, d, n))

# picoCTF{bad_1d3a5_5533202}

Flag: picoCTF{bad_1d3a5_5533202}
```


<h3>b00tl3gRSA3 - Points: 450</h3>
Why use p and q when I can use more? Connect with nc 2019shell1.picoctf.com 47259.


c= 1364904599811961431432299207381321739175672316681954485782630739167675043810206175851288052388589792271927725132698648557357341423492317034400078044724086520122041133467171061987941889275469329651493671414436660103169200702441308620637440833652768327197860146858672899772386537792750466561451180552950674532605167900294099581239357494422574812


n= 7011066666284937964179770021985221046134481183995075844378897321466187112464189631803296154478420726308147926385185458031873030867606699140090527712100592056727307566753250610814621296295323383772042813724157811038540816563205142677326497602746909115833323489564824027958841105649767158102212095960414349313684285590928984404416843417149799293


e= 65537

``` shell

# 34 factors with Cryptool blue
p1=8650603061
p2=8808788047
p3=8915352643
p4=8940672227
p5=9015437741
p6=9392357731
p7=9995214323
p8=10211747827
p9=10421416543
p10=10870824229
p11=11107226213
p12=11360174279
p13=11505706111
p14=11617556371
p15=11684464133
p16=11929298167
p17=11987744983
p18=12166146697
p19=12578347759 
p20=12695339399
p21=12938827049
p22=13879123649
p23=14161485971
p24=14193713749
p25=14242362809
p26=14266565479
p27=14565652229
p28=14593703821
p29=14805142691
p30=15275313419
p31=15488797769
p32=15594695183
p33=15767061173
p34=16034754499


primes = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, p30, p31, p32, p33, p34]

e = 65537

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


# From https://crypto.stackexchange.com/questions/31109/rsa-enc-decryption-with-multiple-prime-modulus-using-crt
ts = []
xs = []
ds = []

for i in range(len(primes)):
	ds.append(modinv(e, primes[i]-1))

m = primes[0]

for i in range(1, len(primes)):
	ts.append(modinv(m, primes[i]))
	m = m * primes[i]

for i in range(len(primes)):
	xs.append(pow((c%primes[i]), ds[i], primes[i]))

x = xs[0]
m = primes[0]

for i in range(1, len(primes)):
	x = x + m * ((xs[i] - x % primes[i]) * (ts[i-1] % primes[i]))
	m = m * primes[i]


print hex(x%n)[2:-1].decode("hex")

# picoCTF{too_many_fact0rs_7031289}

Flag: picoCTF{too_many_fact0rs_7031289}
```


<h3>john_pollard - Points: 500</h3>
Sometimes RSA certificates are breakable

``` shell
root@Bl4st3r:/media/sf_D_DRIVE/picoctf19/crypto# openssl x509 -in cert -text -modulus
Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number: 12345 (0x3039)
        Signature Algorithm: md2WithRSAEncryption
        Issuer: CN = PicoCTF
        Validity
            Not Before: Jul  8 07:21:18 2019 GMT
            Not After : Jun 26 17:34:38 2019 GMT
        Subject: OU = PicoCTF, O = PicoCTF, L = PicoCTF, ST = PicoCTF, C = US, CN = PicoCTF
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (53 bit)
                Modulus: 4966306421059967 (0x11a4d45212b17f)
                Exponent: 65537 (0x10001)
    Signature Algorithm: md2WithRSAEncryption
         07:6a:5d:61:32:c1:9e:05:bd:eb:77:f3:aa:fb:bb:83:82:eb:
         9e:a2:93:af:0c:2f:3a:e2:1a:e9:74:6b:9b:82:d8:ef:fe:1a:
         c8:b2:98:7b:16:dc:4c:d8:1e:2b:92:4c:80:78:85:7b:d3:cc:
         b7:d4:72:29:94:22:eb:bb:11:5d:b2:9a:af:7c:6b:cb:b0:2c:
         a7:91:87:ec:63:bd:22:e8:8f:dd:38:0e:a5:e1:0a:bf:35:d9:
         a4:3c:3c:7b:79:da:8e:4f:fc:ca:e2:38:67:45:a7:de:6e:a2:
         6e:71:71:47:f0:09:3e:1b:a0:12:35:15:a1:29:f1:59:25:35:
         a3:e4:2a:32:4c:c2:2e:b4:b5:3d:94:38:93:5e:78:37:ac:35:
         35:06:15:e0:d3:87:a2:d6:3b:c0:7f:45:2b:b6:97:8e:03:a8:
         d4:c9:e0:8b:68:a0:c5:45:ba:ce:9b:7e:71:23:bf:6b:db:cc:
         8e:f2:78:35:50:0c:d3:45:c9:6f:90:e4:6d:6f:c2:cc:c7:0e:
         de:fa:f7:48:9e:d0:46:a9:fe:d3:db:93:cb:9f:f3:32:70:63:
         cf:bc:d5:f2:22:c4:f3:be:f6:3f:31:75:c9:1e:70:2a:a4:8e:
         43:96:ac:33:6d:11:f3:ab:5e:bf:4b:55:8b:bf:38:38:3e:c1:
         25:9a:fd:5f
Modulus=11A4D45212B17F
-----BEGIN CERTIFICATE-----
MIIB6zCB1AICMDkwDQYJKoZIhvcNAQECBQAwEjEQMA4GA1UEAxMHUGljb0NURjAe
Fw0xOTA3MDgwNzIxMThaFw0xOTA2MjYxNzM0MzhaMGcxEDAOBgNVBAsTB1BpY29D
VEYxEDAOBgNVBAoTB1BpY29DVEYxEDAOBgNVBAcTB1BpY29DVEYxEDAOBgNVBAgT
B1BpY29DVEYxCzAJBgNVBAYTAlVTMRAwDgYDVQQDEwdQaWNvQ1RGMCIwDQYJKoZI
hvcNAQEBBQADEQAwDgIHEaTUUhKxfwIDAQABMA0GCSqGSIb3DQEBAgUAA4IBAQAH
al1hMsGeBb3rd/Oq+7uDguueopOvDC864hrpdGubgtjv/hrIsph7FtxM2B4rkkyA
eIV708y31HIplCLruxFdspqvfGvLsCynkYfsY70i6I/dOA6l4Qq/NdmkPDx7edqO
T/zK4jhnRafebqJucXFH8Ak+G6ASNRWhKfFZJTWj5CoyTMIutLU9lDiTXng3rDU1
BhXg04ei1jvAf0UrtpeOA6jUyeCLaKDFRbrOm35xI79r28yO8ng1UAzTRclvkORt
b8LMxw7e+vdIntBGqf7T25PLn/MycGPPvNXyIsTzvvY/MXXJHnAqpI5DlqwzbRHz
q16/S1WLvzg4PsElmv1f
-----END CERTIFICATE-----

Modulus is 4966306421059967 or (0x11a4d45212b17f)
We know that p > q 

Flag: picoCTF{73176001,67867967}
```

<p align="left"><a href="https://github.com/Ne0Lux-C1Ph3r/WRITE-UP/blob/master/picoCTF2019/index.md">Return to the main menu</a></p>

